[
  {
    "objectID": "posts/String_Flow_Control.html",
    "href": "posts/String_Flow_Control.html",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "",
    "text": "This work aims to practice physics exercises using strings, list and loops, comparison dan flow control to solve the problem in Python. There are some solutions for tasks in this Python code."
  },
  {
    "objectID": "posts/String_Flow_Control.html#strings",
    "href": "posts/String_Flow_Control.html#strings",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "1. Strings",
    "text": "1. Strings"
  },
  {
    "objectID": "posts/String_Flow_Control.html#p3.1",
    "href": "posts/String_Flow_Control.html#p3.1",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "P3.1",
    "text": "P3.1\nProduce a nicely formatted list of the values of the physical constants, h, c, \\(k_{B}\\), R, and \\(N_{A}\\), to four significant figures, with their units.\n\nh, h_units = 6.62607015e-34, 'J.s'\nc, c_units = 299792458, 'm.s-1'\nkB, kB_units = 1.380649e-23, 'J.K-1'\nR, R_units = 8.314462618, 'J.K.mol-1'\nN_A, N_A_units = 6.02214076e+23, 'mol-1'\n\ns1 = (f'h = {h:9.3e} {h_units}\\t'\n     f'c = {c:9.3e} {c_units}\\t' \n      f'kB = {kB:9.3e} {kB_units}\\t'\n       f'R = {R:9.3e} {R_units}\\t'\n        f'N_A = {N_A:9.3e} {N_A_units}\\t')\n\ns2 = (f'h   = {h:9.3e}{h_units}\\n'\n      f'c   = {c:9.3e}{c_units}\\n' \n      f'kB  = {kB:9.3e}{kB_units}\\n'\n      f'R   = {R:9.3e}{R_units}\\n'\n      f'N_A = {N_A:9.3e}{N_A_units}\\n')\nprint(s1)\n\nprint(s2)\n\nh = 6.626e-34 J.s   c = 2.998e+08 m.s-1 kB = 1.381e-23 J.K-1    R = 8.314e+00 J.K.mol-1 N_A = 6.022e+23 mol-1   \nh   = 6.626e-34J.s\nc   = 2.998e+08m.s-1\nkB  = 1.381e-23J.K-1\nR   = 8.314e+00J.K.mol-1\nN_A = 6.022e+23mol-1"
  },
  {
    "objectID": "posts/String_Flow_Control.html#p3.2",
    "href": "posts/String_Flow_Control.html#p3.2",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "P3.2",
    "text": "P3.2\nThe following variables define some thermodynamic properties of \\(CO_{2}\\) and \\(H_{2}O\\).\n\n# Triple point of CO2 (K, Pa)\nT3_CO2, p3_CO2 = 216.58, 5.185e5\n# Entalphy of fusion of CO2 (kJ.mol-1).\nDfusH_CO2 = 9.019\n# Entrophy of fusion os CO2 (J.K-1.mol-1).\nDfusS_CO2 = 40\n# Entalphy of vaporization of CO2 (kJ.mol-1).\nDvapH_CO2 = 15.326\n# Entrophy of vaporization of CO2 (J.K-1.mol-1).\nDvapS_CO2 = 70.8\n\n# Triple point of H2O (K, Pa)\nT3_H2O, p3_H2O = 273.16, 611.73\n# Entalphy of fusion of H2O (kJ.mol-1).\nDfusH_H2O = 6.01\n# Entrophy of fusion of H2O (J.K-1.mol-1).\nDfusS_H2O = 22.0\n# Entalphy of vaporization of H2O (kJ.mol-1).\nDvapH_H2O = 40.68\n# Entrophy of vaporization of H2O (J.K-1.mol-1).\nDvapS_H2O = 118.89\n\nprint(' '*22 + 'CO2' + ' '*9 + 'H20')\nprint('_'*40)\nprint('p3     /pa         ', f'{p3_CO2:5.0f}      {p3_H2O:5.2f}')\nprint('T3     /K          ', f'{T3_CO2:5.2f}      {T3_H2O:5.2f}')\nprint('DfusH  /kJ.mol-1   ', f'{DfusH_CO2:5.3f}       {DfusH_H2O:5.3f}')\nprint('DfusS  /J.K-1.mol-1', f'{DfusS_CO2:4.1f}      {DfusS_H2O:6.1f}')\nprint('DvapH  /kJ.mol-1   ', f'{DvapH_CO2:5.3f}    {DvapH_H2O:8.3f}')\nprint('DvapS  /j.k-1.mol-1', f'{DvapS_CO2:5.1f}       {DvapS_H2O:5.1f}')\n\n\n                      CO2         H20\n________________________________________\np3     /pa          518500      611.73\nT3     /K           216.58      273.16\nDfusH  /kJ.mol-1    9.019       6.010\nDfusS  /J.K-1.mol-1 40.0        22.0\nDvapH  /kJ.mol-1    15.326      40.680\nDvapS  /j.k-1.mol-1  70.8       118.9"
  },
  {
    "objectID": "posts/String_Flow_Control.html#p3.3",
    "href": "posts/String_Flow_Control.html#p3.3",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "P3.3",
    "text": "P3.3\nNuclear binding energy and the mass defect. A neutron has a slightly larger mass than the proton. These are often given in terms of an atomic mass unit, where one atomic mass unit (u) is defined as 1/12th the mass of a carbon-12 atom.\n\n# Mass Particle constant, in kg.\natomic_kg = 1.660540 * 10 ** -27\nneutron_kg = 1.674929 * 10 ** -27\nproton_kg = 1.672623 * 10 ** -27 \nelectron_kg = 9.109390 * 10 ** -31\n\n# Mass particle, in u.\natomic_u = 1.000 \nneutron_u = neutron_kg / atomic_kg \nproton_u = proton_kg / atomic_kg\nelectron_u = electron_kg / atomic_kg\n\n# Mass particle, in MeV/c2\natomic_ev = 931.5\nneutron_ev = neutron_u * atomic_ev\nproton_ev = proton_u * atomic_ev\nelectron_ev = electron_u * atomic_ev\n\n\ntitle = '|' + ' '*19 + '{:43}'.format('Binding Nuclear Energy') + '|'\nline = '+' + '-'*16 + '+' + ('-'*14 + '+')*3\nrow = '|{:&lt;15} |' + ' {:12} |'*3\nheader = '| {:^14} |'.format('Particle') + (' {:^12} |'*3). format('Mass (kg)', 'Mass (u)', 'Mass (Mev/c2)')\n\nprint('+' + '-'*(len(title)-2) + '+',\n      title,\n      line,\n      header,\n      line,\n      row.format('atomic mass', atomic_kg, f'{atomic_u:8.3f}', f'{atomic_ev:6}'),\n      row.format('neutron', neutron_kg, f'{neutron_u:8.7f}', f'{neutron_ev:8.2f}'),\n      row.format('proton', proton_kg, f'{proton_u:8.7f}', f'{proton_ev:8.2f}'), \n      row.format('electron', electron_kg, f'{electron_u:8.7f}', f'{electron_ev:8.3f}'),\n      line,\n      sep='\\n')\n                                                                   \n\n+--------------------------------------------------------------+\n|                   Binding Nuclear Energy                     |\n+----------------+--------------+--------------+--------------+\n|    Particle    |  Mass (kg)   |   Mass (u)   | Mass (Mev/c2) |\n+----------------+--------------+--------------+--------------+\n|atomic mass     |  1.66054e-27 |    1.000     |  931.5       |\n|neutron         | 1.674929e-27 | 1.0086653    |   939.57     |\n|proton          | 1.672623e-27 | 1.0072765    |   938.28     |\n|electron        |  9.10939e-31 | 0.0005486    |    0.511     |\n+----------------+--------------+--------------+--------------+"
  },
  {
    "objectID": "posts/String_Flow_Control.html#list-and-loops",
    "href": "posts/String_Flow_Control.html#list-and-loops",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "2. List and Loops",
    "text": "2. List and Loops"
  },
  {
    "objectID": "posts/String_Flow_Control.html#p3.4",
    "href": "posts/String_Flow_Control.html#p3.4",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "P3.4",
    "text": "P3.4\nStraight-chain alkanes are hydrocarbons with the general stoichiometric formula \\(C_{n}H_{2n+2}\\), in which the carbon atoms form a simple shain: for example, butane, \\(C_{4}H_{10}\\) has the structural formula that may be depicted \\(H_{3}CC_{2}CH_{2}CH_{3}\\). Write a progra, to output the structural formula of such an alkane, given its stoichiometry (assume \\(n\\geq1\\)).\n\n# Assume n = 5\nstoich = 'C5H12'\nfragments = stoich.split('H')\nnC = int(fragments[0][1:])\nnH = int(fragments[1])\nif nH != 2*nC + 2:\n    print('{} is not alkane!'.format(atoich))\nelse:\n    print('H\\u2083C', end='')\n    for i in range(nC-2):\n        print('-CH\\u2082', end='')\n    print('-CH\\u2083')\n\nH₃C-CH₂-CH₂-CH₂-CH₃"
  },
  {
    "objectID": "posts/String_Flow_Control.html#p3.5",
    "href": "posts/String_Flow_Control.html#p3.5",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "P3.5",
    "text": "P3.5\nProduce a table if the FCC element symbols abd their corresponding atomic radius (nm) and atomic weight (g/mol).\n\nsymbols = ['Al', 'Cu', 'Au', 'Pb', 'Ni', 'Pt', 'Ag']\nAtomic_radiuss = [0.1431, 0.1278, 0.1442, 0.1750, 0.1246, 0.1387, 0.1445]\nAtomic_weigth = [26.981, 63.546, 196.966, 206.14, 58.693, 195.084, 107.868]\nline = '-'*52\nprint(line)\nprint('Elements | Atomic Radii (nm) | Atomic weight (g/mol)')\nprint(line)\nfor i in range(len(symbols)):\n    print(' '*2, symbols[i], ' '*5, Atomic_radiuss[i], ' '*13, Atomic_weigth[i])\n    print(line)\n\n----------------------------------------------------\nElements | Atomic Radii (nm) | Atomic weight (g/mol)\n----------------------------------------------------\n   Al       0.1431               26.981\n----------------------------------------------------\n   Cu       0.1278               63.546\n----------------------------------------------------\n   Au       0.1442               196.966\n----------------------------------------------------\n   Pb       0.175               206.14\n----------------------------------------------------\n   Ni       0.1246               58.693\n----------------------------------------------------\n   Pt       0.1387               195.084\n----------------------------------------------------\n   Ag       0.1445               107.868\n----------------------------------------------------"
  },
  {
    "objectID": "posts/String_Flow_Control.html#p3.6",
    "href": "posts/String_Flow_Control.html#p3.6",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "P3.6",
    "text": "P3.6\nreference: - https://en.wikipedia.org/wiki/Atomic_radii_of_the_elements_(data_page)\nAlumunium, copper and lead has an atomic radius of 121, 132, and 146 nm, respectively, an FCC crystal structure, and atomic weight of 26.98, 63.55, and 207.20 g/mol. Compute their theoritical density,and compare the answer with their measured density.\nFace centered cubic (fcc) structure\n\n\n\nimage.png\n\n\nCredit: Callister & Rethwisch\nin the FCC unit cell illustrated, the atoms touch one another across a face-diagonal, the length of which is 4R. Because the unit cell is a cube, its volume is \\(a^{3}\\), where a is the cell edge length. From the right triangle on the face.\n\\(a^{2} + a^{2} = (4R)^{2}\\)\nSolving for a,\n\\(a=2R\\sqrt{2}\\)\nThe FCC unit cell volume \\(V_{C}\\) may be computed from\n\\(V_{C}=a^{3}=(2\\sqrt{2})^{3}=16R^{3}\\sqrt{2}\\)\n\nimport numpy as np\n# Avogadro's number , in atoms/mol.\nNA = 6.022 * 10 **23\n\n# The number of atoms per unit cell in FCC\nn = 4\n\n# The atomic weight, and Radii of atoms (use floats/ints instead of strings)\nAtomics = ['Al', 'Cu', 'Pb'] # use string ' '\nA_weight = [26.98, 63.55, 207.20] # atomic weights in g/mol use float\nRadii = [143 * 10 **-10, 128 * 10 **-10, 180 * 10 **-10] # radii in cm (converted from pm) use float/integers\n\n# Computational density\nfor atom, weight, radius in zip(Atomics, A_weight, Radii):\n    V_cell = 16 * (radius**3) * np.sqrt(2)\n    m_cell = 4 * weight\n    rho = m_cell / (V_cell *NA)\n    print(f\" {atom}: V_cell={V_cell:.3e} cm^3, m_cell={m_cell:.3e} g, rho={rho:.3f} g/cm^3\")\n\n Al: V_cell=6.617e-23 cm^3, m_cell=1.079e+02 g, rho=2.708 g/cm^3\n Cu: V_cell=4.745e-23 cm^3, m_cell=2.542e+02 g, rho=8.895 g/cm^3\n Pb: V_cell=1.320e-22 cm^3, m_cell=8.288e+02 g, rho=10.429 g/cm^3"
  },
  {
    "objectID": "posts/String_Flow_Control.html#p3.7",
    "href": "posts/String_Flow_Control.html#p3.7",
    "title": "Applying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises",
    "section": "P3.7",
    "text": "P3.7\nDetermine whether each of the following electron configuration is an inert gas,a halogen, an alkali metal, an alkaline earth metal, or transition metal. Justify your choices.\n(a) 1s2.2s2.2p6.3s2.3p5\n(b) 1s2.2s2.2p6.3s2.3p6.3d7.4s2\n(c) 1s2.2s2.2p6.3s2.3p6.3d7.4s2.4P6\n(d) 1s2.2s2.2p6.3s2.3p6.4s1\n(e) 1s2.2s2.2p6.3s2.3p6.3d7.4s2.4p6.4d10.5s2\n(f) 1s2.2s2.2p6.3s2\n\n# Electron configuration\nconfigs = {\n    '(a)': '1s2.2s2.2p6.3s2.3p5',\n    '(b)': '1s2.2s2.2p6.3s2.3p6.3d7.4s2',\n    '(c)': '1s2.2s2.2p6.3s2.3p6.3d10.4s2.4p6',\n    '(d)': '1s2.2s2.2p6.3s2.3p6.4s1',\n    '(e)': '1s2.2s2.2p6.3s2.3p6.3d7.4s2.4p6.4d5.5s2',\n    '(f)': '1s2.2s2.2p6.3s2'}\n\ndef classify_configuration(cfg: str):\n    subshells = cfg.split(\".\")\n    parsed = []\n\n    # Parse subshells into (n, orbital, electrons)\n    for s in subshells:\n        try:\n            n = int(s[0])          # principal quantum number\n            orbital = s[1]         # orbital type (s, p, d, f)\n            electrons = int(s[2:]) # electron count\n            parsed.append((n, orbital, electrons))\n        except:\n            continue\n\n    if not parsed:\n        return \"Unknown\"\n\n    #Classify configuration electron by the last and the second-last subshells\n    last_orbital, last_e = parsed[-1][1], parsed[-1][2]\n    second_orbital, second_e = parsed[-2][1], parsed[-2][2] if len(parsed) &gt;= 2 else (None, None)\n\n    # Rules\n    if last_orbital == \"p\" and last_e == 6:\n        return \"Inert gas (Noble gas)\"\n    elif last_orbital == \"p\" and last_e == 5:\n        return \"Halogen\"\n    elif last_orbital == \"s\" and last_e == 1:\n        return \"Alkali metal\"\n    elif last_orbital == \"s\" and last_e ==2:\n        if second_orbital == \"p\" and second_e == 6:\n            return \"Akaline Earth metal\"\n        elif second_orbital ==\"d\" and second_e &lt;10:\n            return \"Transition metal\"\n \n# print results\nfor label, cfg in configs.items():\n    print(f\"{label} {cfg} =&gt; {classify_configuration(cfg)}\")\n\n(a) 1s2.2s2.2p6.3s2.3p5 =&gt; Halogen\n(b) 1s2.2s2.2p6.3s2.3p6.3d7.4s2 =&gt; Transition metal\n(c) 1s2.2s2.2p6.3s2.3p6.3d10.4s2.4p6 =&gt; Inert gas (Noble gas)\n(d) 1s2.2s2.2p6.3s2.3p6.4s1 =&gt; Alkali metal\n(e) 1s2.2s2.2p6.3s2.3p6.3d7.4s2.4p6.4d5.5s2 =&gt; Transition metal\n(f) 1s2.2s2.2p6.3s2 =&gt; Akaline Earth metal"
  },
  {
    "objectID": "posts/index-welcome.html",
    "href": "posts/index-welcome.html",
    "title": "Welcome To Chemistry-Physics Code",
    "section": "",
    "text": "This work aims to practice chemistry and physics exercises using Python as a calculator.\nThere are some solutions for tasks in this Python code.\nPython-based solutions: simple scripts that demonstrate how to use Python for scientific problem-solving."
  },
  {
    "objectID": "posts/index-welcome.html#welcome-to-the-meaningful-code",
    "href": "posts/index-welcome.html#welcome-to-the-meaningful-code",
    "title": "Welcome To Chemistry-Physics Code",
    "section": "",
    "text": "This work aims to practice chemistry and physics exercises using Python as a calculator.\nThere are some solutions for tasks in this Python code.\nPython-based solutions: simple scripts that demonstrate how to use Python for scientific problem-solving."
  },
  {
    "objectID": "posts/Functions.html",
    "href": "posts/Functions.html",
    "title": "Functions, Data Structures, and File Input or Output",
    "section": "",
    "text": "This work aims to applying the concept of Functions, Data Structures, and File Input/Output for solving physics problems by Python 3 and Jupyter Notebook.\nThere are some solutions for tasks in this Python code."
  },
  {
    "objectID": "posts/Functions.html#function",
    "href": "posts/Functions.html#function",
    "title": "Functions, Data Structures, and File Input or Output",
    "section": "1. Function",
    "text": "1. Function"
  },
  {
    "objectID": "posts/Functions.html#p4.1---the-solar-mass",
    "href": "posts/Functions.html#p4.1---the-solar-mass",
    "title": "Functions, Data Structures, and File Input or Output",
    "section": "P4.1 - The solar mass",
    "text": "P4.1 - The solar mass\nCalculate the solar mass. The solar mass can be calculated by using the relation:\n\\(M_{Sun}=\\frac{4\\pi^{2}(1 AU)^{3}}{G (1 yr)^{2}}\\)\nIn this task we will use approximate values for AU and G. The unit AU is an astronomical unit of length. Its value is defined to be the average distance between the Sun and Earth:\n1 AU = 1.496 x \\(10^{11}\\) m\nwhere 1 lightyear = 9.5 x \\(10^{12}\\) km. The constant G is called the gravitational constant and has the following value:\nG = 6.674 X \\(10^{-11}m^{3}kg^{-1}s^{-1}\\)\n\n# The Astronomical unit of length, in meters\nAU = 1.496e11\n\n# The orbital period o Earth in seconds, for one year\nyr = 365.256 * 24 * 3600\n\n# The Gravitational constant, in m3.kg-1,s-2\nG = 6.674e-11\n\n# Calculate the solar mass, in kg\nimport math\ndef Solar_mass():\n    M_Sun = (4 * math.pi ** 2 * AU**3) / (G * yr**2)\n    return M_Sun\n\nprint(Solar_mass())\n    \n\n1.9885939441528014e+30"
  },
  {
    "objectID": "posts/Functions.html#p4.2---the-velocity-of-an-atom",
    "href": "posts/Functions.html#p4.2---the-velocity-of-an-atom",
    "title": "Functions, Data Structures, and File Input or Output",
    "section": "P4.2 - The velocity of an atom",
    "text": "P4.2 - The velocity of an atom\nThe atoms within a material is structured such that they create a lattice. We will look at an atom which moves along the surface of a material. Since the atoms are aligned as a lattice, we could use a periodic model to find the velocity of the atom moving across the surface:\n\\(v(x)=\\sqrt{v_{0}^{2}+\\frac{2F_{0}}{m}(cos\\frac{x}{n}-1)}\\)\nwhere m is the mass of the atom, x is the position, v0 is its initial velocity and n is a scaled distance between the atoms within the material. We set the force F0 = 1N. Find the velocity of the atom when x = 1, v0 = 2, n = 4 and m = 3.\n\nRepeat the calculation for Zn, Cu, and Ni for F0 = 1 x \\(10^{-25}\\) N\n\n\nv0 = 2 # the velocity of atom\nx =1 # the position of atom\nm = 3 # the mass of atom\nn = 4 # scaled distanced between atom within the material\nF0 = 1 # The force in N\n\n# Calculate the velocity of atom\nimport numpy as np\ndef velocity_atom():\n    v_a = np.sqrt(v0**2 + (2 *F0 / m) * (np.cos(x/n)-1))\n    return v_a\nprint(velocity_atom())\n\n1.9948120081368812\n\n\n\nv0 = 2 # the velocity of atom\nx =1 # the position of atom\nn = 4 # scaled distanced between atom within the material\nF0 = 1e-25 # The force in N\n\n# Calculate for atom Zn, Cu, and Ni\nA_units = 1.6605e-27 # Atomic per units in kg\n\n# Calculate mass of Zn, Cu, and Ni\nmasses = {\n    \"Zn\": 65.38 * 1.6605e-27,\n    \"Cu\": 63.55 * 1.6605e-27,\n    \"Ni\": 58.69 * 1.6605e-27\n}\n\nimport numpy as np\ndef velocity_atom(atom):\n    m = masses[atom]\n    velocity = v0 **2 + (2 *F0 / m) * (np.cos(x/n)-1)\n    return np.sqrt(velocity) if velocity &gt;= 0 else None\n\nfor atom in masses:\n    print(f\"{atom}: {velocity_atom(atom)}\")\n    \n\nZn: 1.9856306859195652\nCu: 1.985215363307596\nNi: 1.9839861380776256"
  },
  {
    "objectID": "posts/Functions.html#data-structures",
    "href": "posts/Functions.html#data-structures",
    "title": "Functions, Data Structures, and File Input or Output",
    "section": "2. Data Structures",
    "text": "2. Data Structures"
  },
  {
    "objectID": "posts/Functions.html#p4.3---the-crystall-lattice-structures",
    "href": "posts/Functions.html#p4.3---the-crystall-lattice-structures",
    "title": "Functions, Data Structures, and File Input or Output",
    "section": "P4.3 - The crystall lattice structures",
    "text": "P4.3 - The crystall lattice structures\nThe crystal lattice structures of the first row transition metal elements are given below. Some elements have different crystal structures under different conditions of temperatures and pressure. Use python sets to group them and determine which metal, - (a) only exist face-centered cubic (fcc), body-centered cubic (bcc), hexagonal-centered cubic (hcp) - (b) exist in two of these structures - (c) do not form an hcp structures.\n\n\n\n\nLattice\nElements\n\n\n\n\nFCC\nCu, Co, Fe, Mn, Ni, Sc\n\n\nBCC\nCr, Fe, Mn, Ti, V\n\n\nHCP\nCo, Ni, Sc, Ti, Zn\n\n\n\n\n\n# set the elements in fcc, bcc, and hcp by lattice type\nfcc = set(['Cu', 'Co', 'Fe', 'Mn', 'Ni', 'Sc'])\nbcc = set(['Cr', 'Fe', 'Mn', 'Ti', 'V'])\nhcp = set(['Co', 'Ni', 'Sc', 'Ti', 'Zn'])\n\n# (a) print only exist fcc, bcc, and hcp\nprint('(a) only_fcc:', fcc - bcc - hcp)\nprint('(a) only_bcc:', bcc - fcc - hcp)\nprint('(a) only_hcp:', hcp - fcc - bcc)\n\n# (b) exist in two structures\nprint('(b) fcc and bcc:', fcc & bcc - hcp)\nprint('(b) fcc and hcp:', fcc & hcp - bcc)\nprint('(b) bcc and hcp:', bcc & hcp - fcc)\n\n# (c) print do not form hcp\nall_metals = fcc | bcc | hcp\n\nprint('(c) no_hcp:', all_metals - hcp)\n\n# (d) print the metals exist in fcc, bcc, and hcp\nprint('(d) fcc and bcc and hcp:', fcc & bcc & hcp)\n\n\n(a) only_fcc: {'Cu'}\n(a) only_bcc: {'V', 'Cr'}\n(a) only_hcp: {'Zn'}\n(b) fcc and bcc: {'Mn', 'Fe'}\n(b) fcc and hcp: {'Co', 'Ni', 'Sc'}\n(b) bcc and hcp: {'Ti'}\n(c) no_hcp: {'V', 'Cu', 'Cr', 'Fe', 'Mn'}\n(d) fcc and bcc and hcp: set()"
  },
  {
    "objectID": "posts/Functions.html#p4.4---magnetic-classification",
    "href": "posts/Functions.html#p4.4---magnetic-classification",
    "title": "Functions, Data Structures, and File Input or Output",
    "section": "P4.4 - Magnetic classification",
    "text": "P4.4 - Magnetic classification\nThe magnetic properties is related to metals. Some elements have different properties under different conditions of temperatures and pressure. Use python sets to group them and determine which category, - (a) only exist diamagnetic, paramagnetic, and non-magnetic. - (b) exist in two of these magnetic. - (c) exist in three of these magnetic.\n\n\n\n\ncategory\nElements\n\n\n\n\nDiamagnetic\nZn, Cu, Sc, Ti\n\n\nParamagnetic\nCr, Mn, V, Fe, Cu, Ti\n\n\nNon-magnetic\nAl, Zn, Sc\n\n\n\n\n\n# set the elements in diamagnetic, paramagnetic and non-magnetic\nDiamagnetic = set(['Zn', 'Cu', 'Sc', 'Ti'])\nParamagnetic = set(['Cr', 'Mn', 'V', 'Fe', 'Cu', 'Ti'])\nNon_magnetic = set(['Al', 'Zn', 'Sc'])\n\n# print only exist diamagnetic, paramagnetic or non-magnetic\nprint('(a) only_Diamagnetic:', Diamagnetic - Paramagnetic - Non_magnetic)\nprint('(a) only_Paramagnetic:', Paramagnetic - Diamagnetic - Non_magnetic)\nprint('(a) only_Nonmagnetoc:', Non_magnetic - Diamagnetic - Paramagnetic)\n\n# Exist in two properties\nprint('(b) Diamagnetic and Paramagnetic:', Diamagnetic & Paramagnetic - Non_magnetic)\nprint('(b) Diamagnetic and Non_magnetic:', Diamagnetic & Non_magnetic - Paramagnetic)\nprint('(b) Paramagnetic and Non_magnetic:', Paramagnetic & Non_magnetic - Diamagnetic)\n\n# Exist in three properties\nall_category = Diamagnetic | Paramagnetic | Non_magnetic\n\nprint('(c) Diamagnetic and Paramagnetic and Non_magnetic:', Diamagnetic & Paramagnetic & Non_magnetic)\n\n(a) only_Diamagnetic: set()\n(a) only_Paramagnetic: {'V', 'Cr', 'Mn', 'Fe'}\n(a) only_Nonmagnetoc: {'Al'}\n(b) Diamagnetic and Paramagnetic: {'Ti', 'Cu'}\n(b) Diamagnetic and Non_magnetic: {'Zn', 'Sc'}\n(b) Paramagnetic and Non_magnetic: set()\n(c) Diamagnetic and Paramagnetic and Non_magnetic: set()"
  },
  {
    "objectID": "posts/Functions.html#p4.5---the-computational-density",
    "href": "posts/Functions.html#p4.5---the-computational-density",
    "title": "Functions, Data Structures, and File Input or Output",
    "section": "P4.5 - The computational density",
    "text": "P4.5 - The computational density\nThe text file atomic-data.txt, which can download directly, contains data for the elements, molar cell, and volume cell for Al, Cu, Pb. Read in data and calculate computational density for each subtances.\n\nimport pandas as pd\n\n# Read the txt file (comma-separated)\ndf = pd.read_csv(\"atomic-data.txt\")\n\nprint(df.head())   # show first 5 rows\n\nfor row in data:\n    element, molar_cell, volume_cell = row\n    molar_cell = float(molar_cell)\n    volume_cell = float(volume_cell)\n    density = molar_cell / volume_cell\n    print(f\"{element}: Density = {density:.2f} g/cm³\")\n\n  elements      \\tm-cell  \\tvolume-cell (cm^3)\n0       Al  1.792000e-22          6.620000e-23\n1       Cu  4.221000e-22          6.750000e-23\n2       Pb  1.376000e-21          1.320000e-22\nAl: Density = 2.71 g/cm³\nCu: Density = 6.25 g/cm³\nPb: Density = 10.42 g/cm³"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "HOME",
    "section": "",
    "text": "NumPy and Matplotlib for Physics problems\n\n\n\nPyhton 3\n\ncode\n\nJupyter Notebook\n\nNumpy\n\nPandas\n\nMatplotlib\n\nPhysics\n\n\n\n\n\n\n\n\n\nDec 6, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nFunctions, Data Structures, and File Input or Output\n\n\n\nPyhton 3\n\ncode\n\nJupyter Notebook\n\nNumpy\n\nPandas\n\nChemistry\n\nPhysics\n\n\n\n\n\n\n\n\n\nApr 6, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nApplying the concept of String, List and Loops, and Comparison and Flow Control for Chemistry exercises\n\n\n\nPyhton 3\n\ncode\n\nJupyter Notebook\n\nChemistry\n\nPhysics\n\n\n\n\n\n\n\n\n\nJan 19, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nPython as Calculator for Chemistry and Physics Problems\n\n\n\nPyhton 3\n\ncode\n\nJupyter Notebook\n\nChemistry\n\nPhysics\n\n\n\n\n\n\n\n\n\nJan 7, 2025\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To Chemistry-Physics Code\n\n\n\nBasic Python for Chemistry Problems\n\n\n\n\n\n\n\n\n\nDec 9, 2024\n\n\nDinda Gusti Ayu\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/index 2.html",
    "href": "posts/index 2.html",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "",
    "text": "Chemistry exercises: calculations involving molar mass, wavelength, and energy.\nPhysics exercises: problems on mechanics, thermodynamics, and electromagnetism."
  },
  {
    "objectID": "posts/index 2.html#features",
    "href": "posts/index 2.html#features",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "",
    "text": "Chemistry exercises: calculations involving molar mass, wavelength, and energy.\nPhysics exercises: problems on mechanics, thermodynamics, and electromagnetism."
  },
  {
    "objectID": "posts/index 2.html#key-equation",
    "href": "posts/index 2.html#key-equation",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "Key Equation",
    "text": "Key Equation\n\nEinsten’s relationship between mass and energy\n\nE = hv = \\(\\frac{hc}{\\lambda}=mc^{2}\\)\n\nDe Broglie’s relationship between mass, speed, and wavelength\n\n\\(\\lambda=\\frac{h}{mv}\\)\n\nHeisenberg’s uncertainty principle\n\n\\((\\Delta{x})[\\Delta({mv})]\\geq\\frac{h}{4\\pi}\\)"
  },
  {
    "objectID": "posts/index 2.html#p2.1",
    "href": "posts/index 2.html#p2.1",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.1",
    "text": "P2.1\nThe rate of the reaction between \\(H_{2}\\) and \\(F_{2}\\) to form HF increases by a factor of 10 when the temperature is increased from \\(25 ^oC\\) to \\(47 ^oC\\). What is the reaction activation energy? Assume the Arhenius equation applies.\n\n# Copied from notebook\nimport numpy as np\n# The gas constant in J.K.mol-1 (4 s.f).\nR = 8.314\n\n# Convert the second temperature from degC to K.\nT1, T2 = 25 + 273, 47 + 273\n\n# Calculation the activation energy in J.mol-1.\nEa = R * np.log(10) / (1/T1 - 1/T2)\nprint(Ea)\n\n82979.20514937383"
  },
  {
    "objectID": "posts/index 2.html#p2.2",
    "href": "posts/index 2.html#p2.2",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.2",
    "text": "P2.2\nCalculate the energy (in eV) of a photon with wavelength of 450 nm. One eV is equivalent to \\(1.6\\) x \\(10^{-19}\\) Joules.\n\n# Copied from notebook\n# Planck's constant, in J.s.\nh = 6.626 * 10 ** -34\n\n# Constant J_per_eV\nJ_per_eV = 1.6 * 10 ** -19\n\n# Convert wavelengths nm to m.\nLambda = 450 * 10 ** -9\n\n# Speed of light, in m.s-1.\nc = 3.0 * 10 ** 8\n\n# Calculate energy of photon in J.\nEnergy_J = h * c / Lambda\nEnergy_J\n\n4.417333333333333e-19"
  },
  {
    "objectID": "posts/index 2.html#p2.3",
    "href": "posts/index 2.html#p2.3",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.3",
    "text": "P2.3\nFrom back-scattering experimental data, the radius of an aluminum nucleus can be calculated to be approximately 5 x 10 meters. The radius of an aluminum atom is known to be 1.43 x 10 meters. Using atomic weight data from your periodic table, calculate the density of an aluminum nucleus. Express your answer in units of g/m.\n\n# Constant radius of alumunium nucleus \nR = 5 * 10 ** -15\n# The mass of alumunium, in amu\nm_amu = 26.98\n\n# Constant atomic mass units to kg.\nm_kg = 1.66 * 10 ** -27\n\n# Convert mass of alumunium from amu to kg.\nm = m_amu * m_kg\n\n# Calculate the volume of the alumunium nucleaus, in m3\nV = 4 / 3 * 3.14 * (R ** 3)\n\n# Calculate the density of the alumunium nucleus, in g.m-1.\nRho = m / V\nprint(f'{m:.3e}, {V:.3e}, {Rho:.3e}')\n\n4.479e-26, 5.233e-43, 8.558e+16"
  },
  {
    "objectID": "posts/index 2.html#p2.4",
    "href": "posts/index 2.html#p2.4",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.4",
    "text": "P2.4\nBody fat (triglyceride) has the average chemical formula \\(C_{55}H_{104}O_{6}\\). In the absence of other mechanism (such as ketosis), its metaboilsm is essentially a low temperature combustion to form carbon dioxide and water.\nCalculate the mass of \\(CO_{2}\\) and \\(H_{2}O\\) produced when 1 kg of fat is “burned off”. Take the molar masses to be M(C) = 12 g \\(mol^{-1}\\) and M (H) = 1 g \\(mol^{-1}\\) and M(O) = 16 g \\(mol^{-1}\\). What percentage of the original mass of fat is exhaled as \\(CO_{2}\\)?.\nThe balanced chemical reaction for the metabolism of the fat \\(C_{55}H_{104}O_{6}\\) is:\n\\(C_{55}H_{104}O_{6}\\) + \\(78O_{2}\\) \\(\\rightarrow\\) \\(55CO_{2}\\) + \\(52H_{2}O\\)\n\n# The molar masses of C, H and O, in g.mol-1.\nM_C = 12\nM_H = 1\nM_O = 16\n\n# Calculate molar masses of fatt, CO2 and H2O, in g.mol-1\nM_fat = (55 * M_C) + (104 * M_H) + (6 * M_O)\nM_CO2 = (1 * M_C) + (2 * M_O)\nM_H2O = (2 * M_H) + (1 * M_O)\n\n# Calculate ratio mass ratios (stoichiometry), in g.\nM_fat_per_mole = 1 * M_fat\nM_CO2_per_mole = 55 * M_CO2\nM_H2O_per_mole = 52 * M_H2O\n\n# Calculate mass CO2 and H2O from 1000 g of fat, in g.\nM_CO2_fat = 1000 * (M_CO2_per_mole / M_fat_per_mole)\nM_H2O_fat = 1000 * (M_H2O_per_mole / M_fat_per_mole)\n\n# Calculate percentage of original mass exhaled CO2 and H2O, in %.\nPercen_CO2 = ((55 * M_C + 2/3 * 6 * M_O) / M_fat) * 100\nPercen_H2O = ((104 * M_H + 1/3 * 6 * M_O) / M_fat) * 100\n\nprint(f'{M_CO2_fat:.2f}, {M_H2O_fat:.2f}, {Percen_CO2:.3f}, {Percen_H2O:.3f}')\n\n2813.95, 1088.37, 84.186, 15.814"
  },
  {
    "objectID": "posts/index 2.html#p2.5",
    "href": "posts/index 2.html#p2.5",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.5",
    "text": "P2.5\nWhat is the boiling point of water on the summit of Mt Everest (8,849 m)?. Assume that the ambient air pressure, p, decrease with altitude, z, according to p = p0 exp(-z/H), Where p0 = 1 atm and take scale height, H to be 8 km. The molar entalpy of vaporization of water is\n\\(\\Delta_{vap}H{m}\\) = 44 kJ \\(mol^{-1}\\)\nThe Clausius-Clapeyron equation is:\n\\(\\frac{dlnp}{dT}\\) = \\(\\frac{\\Delta_{vap}H{m}}{RT^{2}}\\)\n\n# Constant the normal boiling point of water T1 at p 1 atm, in K.\nT1 = 100 + 273\n\n# The moalr entalphy of vaporization, in J.mol-1.\nDelta_H_vap = 44 * 1000\n\n# The ideal gas constant, in J.mol-1.K-1.\nR = 8.314\n\n# Height of Everest, in m.\nz = 8849\n\n# The height scale, in m.\nH = 8 * 1000\n\nimport numpy as np\n# Calculate pressure with p0 = 1 atm, in atm.\nP1 = 1\nP2 = P1 * np.exp(-z / H)\n\n# Calculate Boiling point use the Clausius-Clapeyron, in K.\nBoil_per_T2= (1 / T1) - ((R / Delta_H_vap) * np.log(P2 / P1))\nP2, Boil_per_T2\n\n# Calculate T2, in K and convet to degC.\nBoil_T2 = (1 / (Boil_per_T2)) - 273\nBoil_T2\n\nnp.float64(73.02405457523281)"
  },
  {
    "objectID": "posts/index 2.html#p2.6",
    "href": "posts/index 2.html#p2.6",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.6",
    "text": "P2.6\nCalculate the ionization energy (in eV) of an electron in the excited state of n = 3 in a hydrogen atom.\n\n# Rydberg's constant, in m-1.\nR = 1.097 * 10 ** 7\n\n# Planck's constant, in J.s\nh = 6.626 * 10 ** -34\n\n# Speed of light, in m.s-1\nc = 3.0 * 10 ** 8\n\n# Constant J_per_eV\nJ_per_eV = 1.6 * 10 ** -19\n\n# The number or orbit\nn = 3\n\n# Calculate energy of an electron in a particular orbit n = 3, in eV.\nEn = -(R * h * c) / (n ** 2)\nEn_eV = En / J_per_eV\n\n# Energy final, in infinite\nE_final = 0\n\n# Calculate the ionization energy\nDelta_E = E_final - En_eV\nDelta_E\n\n1.5143170833333335"
  },
  {
    "objectID": "posts/index 2.html#p2.7",
    "href": "posts/index 2.html#p2.7",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.7",
    "text": "P2.7\nThe pfund series of lines in the emission spectrum of hydrogen correspond to transition from higher excited states to the n = 5 orbit. Calculate the wavelength of the second line in the Pfund series to three significant figures. In which region of the spectrum does it lie?\n\n# Rydberg's constant, in m-1.\nR = 1.097 * 10 ** 7\n\n# Orbit at the second state and initial state, in orbit.\nn2 = 7 ** 2\nn1 = 5 ** 2\n\n# Calculate the wavelength use the Rydberg equation, in nm.\nLambda_m = 1 / (R * ((1 / n1) - (1 /n2)))\nLambda_nm = Lambda_m * 10 ** 9\nLambda_nm\n\n4652.841081738073"
  },
  {
    "objectID": "posts/index 2.html#p2.8",
    "href": "posts/index 2.html#p2.8",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.8",
    "text": "P2.8\nDetermine the wavelength of radiation (in nm) emitted by a transition from n=5 to n=3 in atomic hydrogen.\n\n# Rydberg's constant, in m-1.\nR = 1.097 * 10 ** 7\n\n# Orbit at the second state and initial state, in orbit.\nn2 = 5 ** 2\nn1 = 3 ** 2\n\n# Calculate the wavelength of radiation, in nm.\nlambda_m = 1/ (R * ((1/n1) - (1/n2)))\nlambda_nm = lambda_m * 10 ** 9\nprint(f'{lambda_nm:.2f}')\n\n1281.91"
  },
  {
    "objectID": "posts/index 2.html#p2.9",
    "href": "posts/index 2.html#p2.9",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.9",
    "text": "P2.9\nCalculate the wavelenght of neutron that is moving at 3.00 x \\(10^{3}\\) m/s.\n\n# the speed moving of neutron, in m/s.\nv = 3.00 * 10 ** 3\n\n# Planck's constant, in J.s\nh = 6.626 * 10 ** -34\n\n# Mass of neutron, in kg.\nm = 1.674929 * 10 ** -27\n\n# Calculate the wavelength of neutron, in Angstrong.\nLambda_m = h / (m * v)\nLambda_A = Lambda_m * 10 ** 10\nLambda_pm = Lambda_m * 10 ** 12\nprint(f'{Lambda_A:.3f}, {Lambda_pm:.3f}')\n\n1.319, 131.866"
  },
  {
    "objectID": "posts/index 2.html#p2.10",
    "href": "posts/index 2.html#p2.10",
    "title": "Python as Calculator for Chemistry and Physics Problems",
    "section": "P2.10",
    "text": "P2.10\nCalculate the minimum uncertainty in the position of an electron traveling at one-third the speed of light, if the uncertainty in its speed $$0.1%. Assumes its mass to be equal to its mass at rest.\n\n# Planck's constant, in J.s\nh = 6.626 * 10 ** -34\n\n# the speed of light, m/s\nc = 3.0 * 10 ** 8\n# Mass of electron, in kg.\nm = 9.109390 * 10 ** -31\n\n# Calculate the uncertainty electron's velocity, in m/c\nv = c / 3 # the electron's velocity is one-third the speed light\ndelta_v = (0.1 / 100) * v # the uncertainty speed is 0.1%\n\n#calculate the uncertainty by Heisenberg equation, in m\ndelta_x = (h/ (4*3.1416)) * (1/(m*delta_v))\nprint(f'{delta_x:.3e}')\n\n5.788e-10"
  },
  {
    "objectID": "posts/Numpy_Matplotlib.html",
    "href": "posts/Numpy_Matplotlib.html",
    "title": "NumPy and Matplotlib for Physics problems",
    "section": "",
    "text": "This work aims to applying the concept of NumPy array and Matplotlib for solving physics problems by Python 3 and Jupyter Notebook. There are some solutions for tasks in this Python code.\n\n\n\nKinematic Equations and Free Fall\n\n\n\n\nSpecial relativity is the area of physics deling with incredibly large velocities. In special relitivity, the momentum p of an object with velocity v(in m/s), and mass m (in kg) is given as.\n\\(p=m.v.\\gamma, \\gamma=\\frac{1}{\\sqrt{1-\\frac{v^{2}}{c^{2}}}}\\)\nwhere c\\(\\approx\\) 300.000.000 m/s is the speed of light. The program below attempts to calculate the momentum of an object with speed equal to 1/3 the speed of light, and mass m = 0.14 kg. The program has many errors, and doesn’t work. Copy and run the program. Correct the errors, and make it work like intended.\n\n# Relativity Einstein\nc = 3e8 # the speed of light in m/s\nv = c / 3 # the velocity 1/3 the speed of light\nm = 0.14 # mass in kg\n\n# Calculate the relativity momentum\nimport numpy as np\ngamma = 1 / (np.sqrt(1-(v/c)**2))\np_momentum = m * v * gamma\n\nprint(f'gamma = {gamma:.6f}')\nprint(f'p_momentum = {p_momentum:.6f}') # the momentum in kg m/s\n\ngamma = 1.060660\np_momentum = 14849242.404917\n\n\n\n\n\nRydberg’s constant \\(R_{\\infty}\\) for a heavy atom is used in physics to calculate the wavelength to spectral lines. The constant has been found to have the following value:\n\\(R_{\\infty}=\\frac{m_{e}e_{4}}{8\\varepsilon_{0}{2}h^{3}c}\\)\nwhere, - \\(m_{e}=9.109 x 10^{-31}\\) m is the mass of an electron - \\(e=1.602 x 10^{-19}\\) C is the charge of a proton (also called the elementary charge) - \\(\\varepsilon_{0}=8.854 x 10^{-12}C V^{-1} m^{-1}\\) is the electrical constant - h = 6.626 x \\(10^{-34}\\) J s is Planck’s constant - c = 3 x \\(10^{8}\\) m/s is the speed of light.\nwrite the program which assigns the values of the physical constants to variables, and use the variables to calculate the value of Rydberg’s constant.\n\n# Calculate Rydberg's constant\nme = 9.109e-31 # mass of an electron\ne = 1.602e-19 # the charge of a proton\nvarepsilon0 = 8.854e-12 # the electrical constant\nh = 6.626e-34 # Planck's constant\nc = 3e8 # speed of the light\n\nR_infinity = (me * e**4)/(8 * varepsilon0**2 * h**3 * c)\nprint(f'R infinity = {R_infinity:.6e}') # the Rydberg's constant\n\n\n\n\nA ball is dropped straight down from a cliff with height \\(\\mathnormal{h}\\). The position of the ball after a time \\(\\mathnormal{t}\\) can be expressed as:\n\\(y(t)=v_{0}t - \\frac{1}{2}at^{2} + h\\)\nwhere a is the acceleration (in \\(m/s^{2})\\) and \\(v_{0}\\) is the initial velocity of the ball (Measured in m/s). We wish to find for how long time \\(t_{1}\\) such that \\(y(t_{1})=h_{1}\\). The position of the ball is measured per \\(\\Delta{t}\\) seconds.\nWrite a program which finds out how long time \\(t_{1}\\) it takes before the ball reaches height \\(h_{1}\\) by using a while loop. \\(h=10 m, y_{1}=5 m, \\Delta{t}=0.01, v_{0}=0 m/s\\) and \\(a = 9.81 m/s^{s}\\).\n\nh = 10 # height in m\ny1 = 5 # position of function of time t1 in m\nv0 = 0 # velocity at t = 0 in m/s\na = 9.81 # acceleration due to gravity in m/s^2\ndt = 0.01 # time step in s\n\n# Calculate how long time t1, if y(t1) = h1.\ny = h # initial positon\nt = 0\nt_values = [t]\ny_values = [y]\n\n\n# The position of the ball is measured per dt seconds\nwhile y &gt; y1:\n    t = t + dt\n    y = v0 * t - 0.5 * a * t**2 + h\n    t_values.append(t)\n    y_values.append(y)\n    \n# at this point, y &lt;= y1\nt1 = t\nprint(f'The ball reaches {y1} m after {t1:.2f} s.')\n\n# The manual instruction\nimport numpy as np\nty1 = np.sqrt(2* (h - y1)/a)\nprint(f'The ball reaches {y1} after {ty1:.3f} s')\n\n# Scatter plot with color map\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nt = np.linspace(0, 2, 200)\ny = 10 -0.5 * 9.81 * t**2\n\n# Create segments for line\npoints = np.array([t,y]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis =1)\n\n# colormap\nLc=LineCollection(segments, cmap='viridis', linewidth=2, norm=plt.Normalize(t.min(), t.max()))\nLc.set_array(t) # color by time\n\nfig, ax = plt.subplots(figsize=(5,4))\nax.scatter(t, y, c=t, cmap='viridis', marker='D')\nax.add_collection(Lc)\nax.autoscale()\n\n# Adding colorbar\ncbar = plt.colorbar(Lc, ax=ax, pad=0.03)\ncbar.set_label('Time (s)')\n\nax.set_xlabel('Time (s)')\nax.set_ylabel('Height (m)')\nax.set_title('Ball Fall Motion with Colormap Line')\nax.grid(True)\nax.set_axisbelow(True)\nplt.savefig('Ballmotion_colormap.svg', bbox_inches='tight')\nplt.show('Ball Fall Motion')\n\nThe ball reaches 5 m after 1.01 s.\nThe ball reaches 5 after 1.010 s\n\n\n\n\n\n\n\n\n\n\nh = 10 # height in m\ny1 = 5 # position of function of time t1 in m\nv0 = 0 # velocity at t = 0 in m/s\na = 9.81 # acceleration due to gravity in m/s^2\ndt = 0.01 # time step in s\n\n# Calculate how long time t1, if y(t1) = h1.\ny = h # initial positon\nt = 0\nt_values = [t]\ny_values = [y]\n\n\n# The position of the ball is measured per dt seconds\nwhile y &gt; y1:\n    t = t + dt\n    y = v0 * t - 0.5 * a * t**2 + h\n    t_values.append(t)\n    y_values.append(y)\n    \n# at this point, y &lt;= y1\nt1 = t\nprint(f'The ball reaches {y1} m after {t1:.2f} s.')\n\n# The manual instruction\nimport numpy as np\nty1 = np.sqrt(2* (h - y1)/a)\nprint(f'The ball reaches {y1} after {ty1:.3f} s')\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(7,5))\nplt.plot(t_values, y_values, label= 'Ball Trajectory', marker='D', markevery=[0, 25, -1], color='b')\nplt.axhline(y=y1, color='red', linestyle='--', label=f'Target height {y} m')\nplt.xlabel('Time (s)',  fontsize=13, fontname='Sans serif')\nplt.ylabel('Height (m)',  fontsize=13, fontname='Sans serif')\nplt.title('Ball Fall Motion', fontsize=16, fontname='Sans serif')\nplt.legend(framealpha=0)\nplt.grid(True)\nplt.show()\n\nThe ball reaches 5 m after 1.01 s.\nThe ball reaches 5 after 1.010 s\n\n\n\n\n\n\n\n\n\n\n\n\nA ball is dropped from rest at a height of h = 100 m. The time intervals is 0.1 s up to 5 s. The constant gravitational acceleration g = 9.81 \\(m/s^{2}\\).(a) What time does the ball hit the ground, (b) what is the velocity of the ball and (c) plot the position of the ball vs time as it falls.\n\nFree Fall Motion\n\nImpact time (when y(t)=0)\n\\(t_{ground}=\\sqrt{\\frac{2h_{0}}{g}}\\)\nInitial Velocity at the ground\n\\(v_{ground}=gt_{ground}\\)\nPosition\n\\(y(t)=h_{0}-\\frac{g}{t^{2}}\\)\n\n\n\n# (a) What time does the ball hits the ground with t_intervals = 0 - 5\n\n# Basic numPy\nimport numpy as numpy\n\nh0 = 100 # initial hight, in m\ng = 9.81 #gravization in m/s^2\n\n\n# Creating numpy arrays (np.linspace(start, stop, num) =&gt; the range built-in\nt = np.linspace(0, 5, 50) # time interval \n\n# Position as a function of time\ny = h0 - 0.5 * g * t**2\n\n# time the ball hits the ground\nt_ground = np.sqrt(2*h0/g)\nprint('(a) Ball hits the ground at t=',round(t_ground, 3), 's')\n\n# Calculate the initial velocity of the ball \nv_ground = g * t_ground\nprint('(b) velocity at the ground =',round(v_ground, 3), 'm/s')\n\n# Set plot the position of the ball vs time as it falls. \nimport matplotlib.pyplot as plt\nplt.figure(figsize=(6,5))\nplt.plot(t, y, marker='D', markevery=[0, 25, -1], color='r', label='position y(t)')\nplt.axhline(0, color='blue', linestyle='--', label='Ground')\nplt.title('Free Fall Motion', fontsize=16, fontname='Sans serif')\nplt.xlabel('Time (s)', fontsize=14, fontname='Sans serif')\nplt.ylabel('Height (m)', fontsize=14, fontname='Sans serif')\nplt.legend()\nplt.legend(framealpha=0)\nplt.grid(True)\nplt.show()\n\n# Scatter plot with color map\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nt = np.linspace(0, 5, 50)\ny = h0 - 0.5 * g * t**2\n\n# Create segments for line\npoints = np.array([t,y]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis =1)\n\n# colormap\nLc=LineCollection(segments, cmap='plasma', linewidth=3, norm=plt.Normalize(t.min(), t.max()))\nLc.set_array(t) # color by time\n\nfig, ax = plt.subplots(figsize=(5,4))\nax.scatter(t, y, c=t, cmap='plasma', marker='D')\nax.add_collection(Lc)\nax.autoscale()\n\n\n# Adding colorbar\ncbar = plt.colorbar(Lc, ax=ax, pad =0.02)\ncbar.set_label('Time (s)')\n\nax.set_xlabel('Time (s)')\nax.set_ylabel('Height (m)')\nax.set_title('Free Fall Motion')\nplt.grid(True)\nax.set_axisbelow(True)\nplt.savefig('Fallmotion_colormap.svg', bbox_inches='tight')\nplt.show('Free Fall Motion')\n\n(a) Ball hits the ground at t= 4.515 s\n(b) velocity at the ground = 44.294 m/s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn classical physics, we define the momentum \\(\\mathnormal{p}\\) of an object with mass \\(\\mathnormal{m}\\) and velocity \\(\\mathnormal{v}\\) as\n                        $p=m x v$\nA satellite with mass m = 1200 kg is trapped in the gravity of a black hole. It accelerates quickly from velocity \\(v=0\\) to \\(v=0.9c\\), where \\(\\mathnormal{c}\\) is the speed of light, \\(c\\approx3x10^{8}\\) m/s.\n\nwrite a program which prints a nicely formatted table to the terminal, containing the speed of the satellite in one column, and the momentum of the satellite in the other. Use time-intervals of \\(0.1c\\) between \\(0c\\) and \\(0.9c\\).\n\nHint: Use scientific notation ‘%e’ when printing the values, to avoid incredibly large floats. Alternatively, ‘%g’, which picks the best notation for you. Try to limit the number of decimals to a reasonable number.\n\n# Parameters \nm = 1200 # mass of satellite in kg\nc = 3e8 # the speed of light on m/s\n \nprint(f'{'Velocity (m/s)':&gt;20} | {'Momentum (kg.m/s)':&gt;25}')\nprint('-' * 45)\n\n# Calculate momentum with the interval velocity 0 to 0.9c\n# Use time-intervals 0f 0.1c between 0c and 0.9c\nfor i in range(10): # time interval from 0c to 0.9c\n    v = i * 0.1 * c # velocity 0 - 0.9c, where c is the the speed of  light.\n    p = m * v\n    print('%20.3g | %25.3g' % (v, p)) # use scientific notation '%g' to limit the number of decimals\n    \n\n# Scatter plot with color map\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nv = np.linspace(0.0, 0.9, 10) * c\np = m * v #Classical Momentum\n\n# Create segments for line\npoints = np.array([v,p]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis =1)\n\n# colormap\nLc=LineCollection(segments, cmap='magma', linewidth=3, norm=plt.Normalize(p.min(), p.max()))\nLc.set_array(p) # color by momentum\n\nfig, ax = plt.subplots(figsize=(10,6))\nax.scatter(v,p, c=p, cmap='magma', marker='o')\nax.add_collection(Lc)\nax.autoscale()\n\n\n# Adding colorbar\nimport matplotlib.ticker as ticker\nfrom matplotlib.ticker import FormatStrFormatter\ncbar = plt.colorbar(Lc, ax=ax, pad =0.02)\ncbar.set_label('Momentum (kg.m/s)')\ncbar.formatter = ticker.FormatStrFormatter('%.2e')\ncbar.update_ticks()\n\n# Axis labels and formatting\nimport matplotlib.ticker as ticker\nfrom matplotlib.ticker import FormatStrFormatter\nax.set_xlabel('Velocity (m/s)')\nax.set_ylabel('Momentum (kg.m/s)')\nax.set_title('Relativistic Momentum', fontsize=14)\nax.xaxis.set_major_formatter(ticker.FormatStrFormatter('%.2e'))\nax.yaxis.set_major_formatter(ticker.FormatStrFormatter('%.2e'))\nplt.grid(True)\nax.set_axisbelow(True)\n\n# Add momentum values\n\nfor vx, px in zip(v, p):\n    ax.text(vx, px, f'{px:.2e}', fontsize=7.5, ha='right', va='bottom')\nplt.savefig('Relativistic_colormap.svg', bbox_inches='tight')\nplt.show('Relativistic Momentum')\n\n      Velocity (m/s) |         Momentum (kg.m/s)\n---------------------------------------------\n                   0 |                         0\n               3e+07 |                   3.6e+10\n               6e+07 |                   7.2e+10\n               9e+07 |                  1.08e+11\n             1.2e+08 |                  1.44e+11\n             1.5e+08 |                   1.8e+11\n             1.8e+08 |                  2.16e+11\n             2.1e+08 |                  2.52e+11\n             2.4e+08 |                  2.88e+11\n             2.7e+08 |                  3.24e+11"
  },
  {
    "objectID": "posts/Numpy_Matplotlib.html#reference",
    "href": "posts/Numpy_Matplotlib.html#reference",
    "title": "NumPy and Matplotlib for Physics problems",
    "section": "",
    "text": "Kinematic Equations and Free Fall"
  },
  {
    "objectID": "posts/Numpy_Matplotlib.html#p5.1---correct-einsteins-mistakes",
    "href": "posts/Numpy_Matplotlib.html#p5.1---correct-einsteins-mistakes",
    "title": "NumPy and Matplotlib for Physics problems",
    "section": "",
    "text": "Special relativity is the area of physics deling with incredibly large velocities. In special relitivity, the momentum p of an object with velocity v(in m/s), and mass m (in kg) is given as.\n\\(p=m.v.\\gamma, \\gamma=\\frac{1}{\\sqrt{1-\\frac{v^{2}}{c^{2}}}}\\)\nwhere c\\(\\approx\\) 300.000.000 m/s is the speed of light. The program below attempts to calculate the momentum of an object with speed equal to 1/3 the speed of light, and mass m = 0.14 kg. The program has many errors, and doesn’t work. Copy and run the program. Correct the errors, and make it work like intended.\n\n# Relativity Einstein\nc = 3e8 # the speed of light in m/s\nv = c / 3 # the velocity 1/3 the speed of light\nm = 0.14 # mass in kg\n\n# Calculate the relativity momentum\nimport numpy as np\ngamma = 1 / (np.sqrt(1-(v/c)**2))\np_momentum = m * v * gamma\n\nprint(f'gamma = {gamma:.6f}')\nprint(f'p_momentum = {p_momentum:.6f}') # the momentum in kg m/s\n\ngamma = 1.060660\np_momentum = 14849242.404917"
  },
  {
    "objectID": "posts/Numpy_Matplotlib.html#p5.2---rydbergs-constant",
    "href": "posts/Numpy_Matplotlib.html#p5.2---rydbergs-constant",
    "title": "NumPy and Matplotlib for Physics problems",
    "section": "",
    "text": "Rydberg’s constant \\(R_{\\infty}\\) for a heavy atom is used in physics to calculate the wavelength to spectral lines. The constant has been found to have the following value:\n\\(R_{\\infty}=\\frac{m_{e}e_{4}}{8\\varepsilon_{0}{2}h^{3}c}\\)\nwhere, - \\(m_{e}=9.109 x 10^{-31}\\) m is the mass of an electron - \\(e=1.602 x 10^{-19}\\) C is the charge of a proton (also called the elementary charge) - \\(\\varepsilon_{0}=8.854 x 10^{-12}C V^{-1} m^{-1}\\) is the electrical constant - h = 6.626 x \\(10^{-34}\\) J s is Planck’s constant - c = 3 x \\(10^{8}\\) m/s is the speed of light.\nwrite the program which assigns the values of the physical constants to variables, and use the variables to calculate the value of Rydberg’s constant.\n\n# Calculate Rydberg's constant\nme = 9.109e-31 # mass of an electron\ne = 1.602e-19 # the charge of a proton\nvarepsilon0 = 8.854e-12 # the electrical constant\nh = 6.626e-34 # Planck's constant\nc = 3e8 # speed of the light\n\nR_infinity = (me * e**4)/(8 * varepsilon0**2 * h**3 * c)\nprint(f'R infinity = {R_infinity:.6e}') # the Rydberg's constant"
  },
  {
    "objectID": "posts/Numpy_Matplotlib.html#p5.3---measure-time",
    "href": "posts/Numpy_Matplotlib.html#p5.3---measure-time",
    "title": "NumPy and Matplotlib for Physics problems",
    "section": "",
    "text": "A ball is dropped straight down from a cliff with height \\(\\mathnormal{h}\\). The position of the ball after a time \\(\\mathnormal{t}\\) can be expressed as:\n\\(y(t)=v_{0}t - \\frac{1}{2}at^{2} + h\\)\nwhere a is the acceleration (in \\(m/s^{2})\\) and \\(v_{0}\\) is the initial velocity of the ball (Measured in m/s). We wish to find for how long time \\(t_{1}\\) such that \\(y(t_{1})=h_{1}\\). The position of the ball is measured per \\(\\Delta{t}\\) seconds.\nWrite a program which finds out how long time \\(t_{1}\\) it takes before the ball reaches height \\(h_{1}\\) by using a while loop. \\(h=10 m, y_{1}=5 m, \\Delta{t}=0.01, v_{0}=0 m/s\\) and \\(a = 9.81 m/s^{s}\\).\n\nh = 10 # height in m\ny1 = 5 # position of function of time t1 in m\nv0 = 0 # velocity at t = 0 in m/s\na = 9.81 # acceleration due to gravity in m/s^2\ndt = 0.01 # time step in s\n\n# Calculate how long time t1, if y(t1) = h1.\ny = h # initial positon\nt = 0\nt_values = [t]\ny_values = [y]\n\n\n# The position of the ball is measured per dt seconds\nwhile y &gt; y1:\n    t = t + dt\n    y = v0 * t - 0.5 * a * t**2 + h\n    t_values.append(t)\n    y_values.append(y)\n    \n# at this point, y &lt;= y1\nt1 = t\nprint(f'The ball reaches {y1} m after {t1:.2f} s.')\n\n# The manual instruction\nimport numpy as np\nty1 = np.sqrt(2* (h - y1)/a)\nprint(f'The ball reaches {y1} after {ty1:.3f} s')\n\n# Scatter plot with color map\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nt = np.linspace(0, 2, 200)\ny = 10 -0.5 * 9.81 * t**2\n\n# Create segments for line\npoints = np.array([t,y]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis =1)\n\n# colormap\nLc=LineCollection(segments, cmap='viridis', linewidth=2, norm=plt.Normalize(t.min(), t.max()))\nLc.set_array(t) # color by time\n\nfig, ax = plt.subplots(figsize=(5,4))\nax.scatter(t, y, c=t, cmap='viridis', marker='D')\nax.add_collection(Lc)\nax.autoscale()\n\n# Adding colorbar\ncbar = plt.colorbar(Lc, ax=ax, pad=0.03)\ncbar.set_label('Time (s)')\n\nax.set_xlabel('Time (s)')\nax.set_ylabel('Height (m)')\nax.set_title('Ball Fall Motion with Colormap Line')\nax.grid(True)\nax.set_axisbelow(True)\nplt.savefig('Ballmotion_colormap.svg', bbox_inches='tight')\nplt.show('Ball Fall Motion')\n\nThe ball reaches 5 m after 1.01 s.\nThe ball reaches 5 after 1.010 s\n\n\n\n\n\n\n\n\n\n\nh = 10 # height in m\ny1 = 5 # position of function of time t1 in m\nv0 = 0 # velocity at t = 0 in m/s\na = 9.81 # acceleration due to gravity in m/s^2\ndt = 0.01 # time step in s\n\n# Calculate how long time t1, if y(t1) = h1.\ny = h # initial positon\nt = 0\nt_values = [t]\ny_values = [y]\n\n\n# The position of the ball is measured per dt seconds\nwhile y &gt; y1:\n    t = t + dt\n    y = v0 * t - 0.5 * a * t**2 + h\n    t_values.append(t)\n    y_values.append(y)\n    \n# at this point, y &lt;= y1\nt1 = t\nprint(f'The ball reaches {y1} m after {t1:.2f} s.')\n\n# The manual instruction\nimport numpy as np\nty1 = np.sqrt(2* (h - y1)/a)\nprint(f'The ball reaches {y1} after {ty1:.3f} s')\n\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(7,5))\nplt.plot(t_values, y_values, label= 'Ball Trajectory', marker='D', markevery=[0, 25, -1], color='b')\nplt.axhline(y=y1, color='red', linestyle='--', label=f'Target height {y} m')\nplt.xlabel('Time (s)',  fontsize=13, fontname='Sans serif')\nplt.ylabel('Height (m)',  fontsize=13, fontname='Sans serif')\nplt.title('Ball Fall Motion', fontsize=16, fontname='Sans serif')\nplt.legend(framealpha=0)\nplt.grid(True)\nplt.show()\n\nThe ball reaches 5 m after 1.01 s.\nThe ball reaches 5 after 1.010 s"
  },
  {
    "objectID": "posts/Numpy_Matplotlib.html#p5.4---free-fall-motion",
    "href": "posts/Numpy_Matplotlib.html#p5.4---free-fall-motion",
    "title": "NumPy and Matplotlib for Physics problems",
    "section": "",
    "text": "A ball is dropped from rest at a height of h = 100 m. The time intervals is 0.1 s up to 5 s. The constant gravitational acceleration g = 9.81 \\(m/s^{2}\\).(a) What time does the ball hit the ground, (b) what is the velocity of the ball and (c) plot the position of the ball vs time as it falls.\n\nFree Fall Motion\n\nImpact time (when y(t)=0)\n\\(t_{ground}=\\sqrt{\\frac{2h_{0}}{g}}\\)\nInitial Velocity at the ground\n\\(v_{ground}=gt_{ground}\\)\nPosition\n\\(y(t)=h_{0}-\\frac{g}{t^{2}}\\)\n\n\n\n# (a) What time does the ball hits the ground with t_intervals = 0 - 5\n\n# Basic numPy\nimport numpy as numpy\n\nh0 = 100 # initial hight, in m\ng = 9.81 #gravization in m/s^2\n\n\n# Creating numpy arrays (np.linspace(start, stop, num) =&gt; the range built-in\nt = np.linspace(0, 5, 50) # time interval \n\n# Position as a function of time\ny = h0 - 0.5 * g * t**2\n\n# time the ball hits the ground\nt_ground = np.sqrt(2*h0/g)\nprint('(a) Ball hits the ground at t=',round(t_ground, 3), 's')\n\n# Calculate the initial velocity of the ball \nv_ground = g * t_ground\nprint('(b) velocity at the ground =',round(v_ground, 3), 'm/s')\n\n# Set plot the position of the ball vs time as it falls. \nimport matplotlib.pyplot as plt\nplt.figure(figsize=(6,5))\nplt.plot(t, y, marker='D', markevery=[0, 25, -1], color='r', label='position y(t)')\nplt.axhline(0, color='blue', linestyle='--', label='Ground')\nplt.title('Free Fall Motion', fontsize=16, fontname='Sans serif')\nplt.xlabel('Time (s)', fontsize=14, fontname='Sans serif')\nplt.ylabel('Height (m)', fontsize=14, fontname='Sans serif')\nplt.legend()\nplt.legend(framealpha=0)\nplt.grid(True)\nplt.show()\n\n# Scatter plot with color map\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nt = np.linspace(0, 5, 50)\ny = h0 - 0.5 * g * t**2\n\n# Create segments for line\npoints = np.array([t,y]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis =1)\n\n# colormap\nLc=LineCollection(segments, cmap='plasma', linewidth=3, norm=plt.Normalize(t.min(), t.max()))\nLc.set_array(t) # color by time\n\nfig, ax = plt.subplots(figsize=(5,4))\nax.scatter(t, y, c=t, cmap='plasma', marker='D')\nax.add_collection(Lc)\nax.autoscale()\n\n\n# Adding colorbar\ncbar = plt.colorbar(Lc, ax=ax, pad =0.02)\ncbar.set_label('Time (s)')\n\nax.set_xlabel('Time (s)')\nax.set_ylabel('Height (m)')\nax.set_title('Free Fall Motion')\nplt.grid(True)\nax.set_axisbelow(True)\nplt.savefig('Fallmotion_colormap.svg', bbox_inches='tight')\nplt.show('Free Fall Motion')\n\n(a) Ball hits the ground at t= 4.515 s\n(b) velocity at the ground = 44.294 m/s"
  },
  {
    "objectID": "posts/Numpy_Matplotlib.html#p5.6--relativistic-momentum",
    "href": "posts/Numpy_Matplotlib.html#p5.6--relativistic-momentum",
    "title": "NumPy and Matplotlib for Physics problems",
    "section": "",
    "text": "In classical physics, we define the momentum \\(\\mathnormal{p}\\) of an object with mass \\(\\mathnormal{m}\\) and velocity \\(\\mathnormal{v}\\) as\n                        $p=m x v$\nA satellite with mass m = 1200 kg is trapped in the gravity of a black hole. It accelerates quickly from velocity \\(v=0\\) to \\(v=0.9c\\), where \\(\\mathnormal{c}\\) is the speed of light, \\(c\\approx3x10^{8}\\) m/s.\n\nwrite a program which prints a nicely formatted table to the terminal, containing the speed of the satellite in one column, and the momentum of the satellite in the other. Use time-intervals of \\(0.1c\\) between \\(0c\\) and \\(0.9c\\).\n\nHint: Use scientific notation ‘%e’ when printing the values, to avoid incredibly large floats. Alternatively, ‘%g’, which picks the best notation for you. Try to limit the number of decimals to a reasonable number.\n\n# Parameters \nm = 1200 # mass of satellite in kg\nc = 3e8 # the speed of light on m/s\n \nprint(f'{'Velocity (m/s)':&gt;20} | {'Momentum (kg.m/s)':&gt;25}')\nprint('-' * 45)\n\n# Calculate momentum with the interval velocity 0 to 0.9c\n# Use time-intervals 0f 0.1c between 0c and 0.9c\nfor i in range(10): # time interval from 0c to 0.9c\n    v = i * 0.1 * c # velocity 0 - 0.9c, where c is the the speed of  light.\n    p = m * v\n    print('%20.3g | %25.3g' % (v, p)) # use scientific notation '%g' to limit the number of decimals\n    \n\n# Scatter plot with color map\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.collections import LineCollection\nv = np.linspace(0.0, 0.9, 10) * c\np = m * v #Classical Momentum\n\n# Create segments for line\npoints = np.array([v,p]).T.reshape(-1, 1, 2)\nsegments = np.concatenate([points[:-1], points[1:]], axis =1)\n\n# colormap\nLc=LineCollection(segments, cmap='magma', linewidth=3, norm=plt.Normalize(p.min(), p.max()))\nLc.set_array(p) # color by momentum\n\nfig, ax = plt.subplots(figsize=(10,6))\nax.scatter(v,p, c=p, cmap='magma', marker='o')\nax.add_collection(Lc)\nax.autoscale()\n\n\n# Adding colorbar\nimport matplotlib.ticker as ticker\nfrom matplotlib.ticker import FormatStrFormatter\ncbar = plt.colorbar(Lc, ax=ax, pad =0.02)\ncbar.set_label('Momentum (kg.m/s)')\ncbar.formatter = ticker.FormatStrFormatter('%.2e')\ncbar.update_ticks()\n\n# Axis labels and formatting\nimport matplotlib.ticker as ticker\nfrom matplotlib.ticker import FormatStrFormatter\nax.set_xlabel('Velocity (m/s)')\nax.set_ylabel('Momentum (kg.m/s)')\nax.set_title('Relativistic Momentum', fontsize=14)\nax.xaxis.set_major_formatter(ticker.FormatStrFormatter('%.2e'))\nax.yaxis.set_major_formatter(ticker.FormatStrFormatter('%.2e'))\nplt.grid(True)\nax.set_axisbelow(True)\n\n# Add momentum values\n\nfor vx, px in zip(v, p):\n    ax.text(vx, px, f'{px:.2e}', fontsize=7.5, ha='right', va='bottom')\nplt.savefig('Relativistic_colormap.svg', bbox_inches='tight')\nplt.show('Relativistic Momentum')\n\n      Velocity (m/s) |         Momentum (kg.m/s)\n---------------------------------------------\n                   0 |                         0\n               3e+07 |                   3.6e+10\n               6e+07 |                   7.2e+10\n               9e+07 |                  1.08e+11\n             1.2e+08 |                  1.44e+11\n             1.5e+08 |                   1.8e+11\n             1.8e+08 |                  2.16e+11\n             2.1e+08 |                  2.52e+11\n             2.4e+08 |                  2.88e+11\n             2.7e+08 |                  3.24e+11"
  }
]